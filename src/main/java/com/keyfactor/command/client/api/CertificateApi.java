/*
 * Keyfactor-v1
 * This reference serves to document REST-based methods to manage and integrate with Keyfactor. In addition, an embedded interface allows for the execution of calls against the current Keyfactor API instance.
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package com.keyfactor.command.client.api;

import com.keyfactor.command.client.ApiCallback;
import com.keyfactor.command.client.ApiClient;
import com.keyfactor.command.client.ApiException;
import com.keyfactor.command.client.ApiResponse;
import com.keyfactor.command.client.Configuration;
import com.keyfactor.command.client.Pair;
import com.keyfactor.command.client.ProgressRequestBody;
import com.keyfactor.command.client.ProgressResponseBody;

import com.google.gson.reflect.TypeToken;

import java.io.IOException;


import com.keyfactor.command.client.model.KeyfactorApiModelsCertificatesAnalyzeCertificateRequest;
import com.keyfactor.command.client.model.KeyfactorApiModelsCertificatesCertificateIdentityAuditResponse;
import com.keyfactor.command.client.model.KeyfactorApiModelsCertificatesCertificateLocationsResponse;
import com.keyfactor.command.client.model.ModelsCertificateDetails;
import com.keyfactor.command.client.model.ModelsCertificateDownloadRequest;
import com.keyfactor.command.client.model.ModelsCertificateDownloadResponse;
import com.keyfactor.command.client.model.ModelsCertificateImportRequestModel;
import com.keyfactor.command.client.model.ModelsCertificateImportResponseModel;
import com.keyfactor.command.client.model.ModelsCertificateRecoveryRequest;
import com.keyfactor.command.client.model.ModelsCertificateRetrievalResponse;
import com.keyfactor.command.client.model.ModelsCertificateValidationResponse;
import com.keyfactor.command.client.model.ModelsMetadataAllUpdateRequest;
import com.keyfactor.command.client.model.ModelsMetadataUpdateRequest;
import com.keyfactor.command.client.model.ModelsPKICertificateOperation;
import com.keyfactor.command.client.model.ModelsRecoveryResponse;
import com.keyfactor.command.client.model.ModelsRevocationRevocationResponse;
import com.keyfactor.command.client.model.ModelsRevokeAllCertificatesRequest;
import com.keyfactor.command.client.model.ModelsRevokeCertificateRequest;
import com.keyfactor.command.client.model.ModelsSecurityCertificatePermissions;

import java.lang.reflect.Type;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import javax.ws.rs.core.GenericType;

public class CertificateApi {
    private ApiClient localVarApiClient;
    private int localHostIndex;
    private String localCustomBaseUrl;

    public CertificateApi() {
        this(Configuration.getDefaultApiClient());
    }

    public CertificateApi(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public ApiClient getApiClient() {
        return localVarApiClient;
    }

    public void setApiClient(ApiClient apiClient) {
        this.localVarApiClient = apiClient;
    }

    public int getHostIndex() {
        return localHostIndex;
    }

    public void setHostIndex(int hostIndex) {
        this.localHostIndex = hostIndex;
    }

    public String getCustomBaseUrl() {
        return localCustomBaseUrl;
    }

    public void setCustomBaseUrl(String customBaseUrl) {
        this.localCustomBaseUrl = customBaseUrl;
    }

    /**
     * Build call for certificateAnalyzeCert
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param request The certificate to analyze (required)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateAnalyzeCertCall(String xKeyfactorRequestedWith, KeyfactorApiModelsCertificatesAnalyzeCertificateRequest request, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = request;

        // create path and map variables
        String localVarPath = "/Certificates/Analyze";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xKeyfactorApiVersion != null) {
            localVarHeaderParams.put("x-keyfactor-api-version", localVarApiClient.parameterToString(xKeyfactorApiVersion));
        }

        if (xKeyfactorRequestedWith != null) {
            localVarHeaderParams.put("x-keyfactor-requested-with", localVarApiClient.parameterToString(xKeyfactorRequestedWith));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateAnalyzeCertValidateBeforeCall(String xKeyfactorRequestedWith, KeyfactorApiModelsCertificatesAnalyzeCertificateRequest request, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xKeyfactorRequestedWith' is set
        if (xKeyfactorRequestedWith == null) {
            throw new ApiException("Missing the required parameter 'xKeyfactorRequestedWith' when calling certificateAnalyzeCert(Async)");
        }

        // verify the required parameter 'request' is set
        if (request == null) {
            throw new ApiException("Missing the required parameter 'request' when calling certificateAnalyzeCert(Async)");
        }

        return certificateAnalyzeCertCall(xKeyfactorRequestedWith, request, xKeyfactorApiVersion, _callback);

    }

    /**
     * Returns the public information of the certificate
     * 
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param request The certificate to analyze (required)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return List&lt;ModelsCertificateDetails&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<ModelsCertificateDetails> certificateAnalyzeCert(String xKeyfactorRequestedWith, KeyfactorApiModelsCertificatesAnalyzeCertificateRequest request, String xKeyfactorApiVersion) throws ApiException {
        ApiResponse<List<ModelsCertificateDetails>> localVarResp = certificateAnalyzeCertWithHttpInfo(xKeyfactorRequestedWith, request, xKeyfactorApiVersion);
        return localVarResp.getData();
    }

    /**
     * Returns the public information of the certificate
     * 
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param request The certificate to analyze (required)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ApiResponse&lt;List&lt;ModelsCertificateDetails&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<ModelsCertificateDetails>> certificateAnalyzeCertWithHttpInfo(String xKeyfactorRequestedWith, KeyfactorApiModelsCertificatesAnalyzeCertificateRequest request, String xKeyfactorApiVersion) throws ApiException {
        okhttp3.Call localVarCall = certificateAnalyzeCertValidateBeforeCall(xKeyfactorRequestedWith, request, xKeyfactorApiVersion, null);
        Type localVarReturnType = new TypeToken<List<ModelsCertificateDetails>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Returns the public information of the certificate (asynchronously)
     * 
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param request The certificate to analyze (required)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateAnalyzeCertAsync(String xKeyfactorRequestedWith, KeyfactorApiModelsCertificatesAnalyzeCertificateRequest request, String xKeyfactorApiVersion, final ApiCallback<List<ModelsCertificateDetails>> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateAnalyzeCertValidateBeforeCall(xKeyfactorRequestedWith, request, xKeyfactorApiVersion, _callback);
        Type localVarReturnType = new TypeToken<List<ModelsCertificateDetails>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateCertificateHistory
     * @param id The Id of the certificate (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId The collection the certificate could be in.  Defaults to no collection. (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param queryPageReturned The current page within the result set to be returned (optional)
     * @param queryReturnLimit Maximum number of records to be returned in a single call (optional)
     * @param querySortField Field by which the results should be sorted (OperationStart, OperationEnd, UserName) (optional)
     * @param querySortAscending Field sort direction [0&#x3D;ascending, 1&#x3D;descending] (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateCertificateHistoryCall(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion, Integer queryPageReturned, Integer queryReturnLimit, String querySortField, Integer querySortAscending, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/Certificates/{id}/History"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (collectionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("collectionId", collectionId));
        }

        if (queryPageReturned != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("query.pageReturned", queryPageReturned));
        }

        if (queryReturnLimit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("query.returnLimit", queryReturnLimit));
        }

        if (querySortField != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("query.sortField", querySortField));
        }

        if (querySortAscending != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("query.sortAscending", querySortAscending));
        }

        if (xKeyfactorApiVersion != null) {
            localVarHeaderParams.put("x-keyfactor-api-version", localVarApiClient.parameterToString(xKeyfactorApiVersion));
        }

        if (xKeyfactorRequestedWith != null) {
            localVarHeaderParams.put("x-keyfactor-requested-with", localVarApiClient.parameterToString(xKeyfactorRequestedWith));
        }

        final String[] localVarAccepts = {
            "application/json",
            "text/json",
            "application/xml",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateCertificateHistoryValidateBeforeCall(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion, Integer queryPageReturned, Integer queryReturnLimit, String querySortField, Integer querySortAscending, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling certificateCertificateHistory(Async)");
        }

        // verify the required parameter 'xKeyfactorRequestedWith' is set
        if (xKeyfactorRequestedWith == null) {
            throw new ApiException("Missing the required parameter 'xKeyfactorRequestedWith' when calling certificateCertificateHistory(Async)");
        }

        return certificateCertificateHistoryCall(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion, queryPageReturned, queryReturnLimit, querySortField, querySortAscending, _callback);

    }

    /**
     * Gets the history of operations on a certificate
     * 
     * @param id The Id of the certificate (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId The collection the certificate could be in.  Defaults to no collection. (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param queryPageReturned The current page within the result set to be returned (optional)
     * @param queryReturnLimit Maximum number of records to be returned in a single call (optional)
     * @param querySortField Field by which the results should be sorted (OperationStart, OperationEnd, UserName) (optional)
     * @param querySortAscending Field sort direction [0&#x3D;ascending, 1&#x3D;descending] (optional)
     * @return List&lt;ModelsPKICertificateOperation&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<ModelsPKICertificateOperation> certificateCertificateHistory(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion, Integer queryPageReturned, Integer queryReturnLimit, String querySortField, Integer querySortAscending) throws ApiException {
        ApiResponse<List<ModelsPKICertificateOperation>> localVarResp = certificateCertificateHistoryWithHttpInfo(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion, queryPageReturned, queryReturnLimit, querySortField, querySortAscending);
        return localVarResp.getData();
    }

    /**
     * Gets the history of operations on a certificate
     * 
     * @param id The Id of the certificate (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId The collection the certificate could be in.  Defaults to no collection. (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param queryPageReturned The current page within the result set to be returned (optional)
     * @param queryReturnLimit Maximum number of records to be returned in a single call (optional)
     * @param querySortField Field by which the results should be sorted (OperationStart, OperationEnd, UserName) (optional)
     * @param querySortAscending Field sort direction [0&#x3D;ascending, 1&#x3D;descending] (optional)
     * @return ApiResponse&lt;List&lt;ModelsPKICertificateOperation&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<ModelsPKICertificateOperation>> certificateCertificateHistoryWithHttpInfo(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion, Integer queryPageReturned, Integer queryReturnLimit, String querySortField, Integer querySortAscending) throws ApiException {
        okhttp3.Call localVarCall = certificateCertificateHistoryValidateBeforeCall(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion, queryPageReturned, queryReturnLimit, querySortField, querySortAscending, null);
        Type localVarReturnType = new TypeToken<List<ModelsPKICertificateOperation>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets the history of operations on a certificate (asynchronously)
     * 
     * @param id The Id of the certificate (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId The collection the certificate could be in.  Defaults to no collection. (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param queryPageReturned The current page within the result set to be returned (optional)
     * @param queryReturnLimit Maximum number of records to be returned in a single call (optional)
     * @param querySortField Field by which the results should be sorted (OperationStart, OperationEnd, UserName) (optional)
     * @param querySortAscending Field sort direction [0&#x3D;ascending, 1&#x3D;descending] (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateCertificateHistoryAsync(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion, Integer queryPageReturned, Integer queryReturnLimit, String querySortField, Integer querySortAscending, final ApiCallback<List<ModelsPKICertificateOperation>> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateCertificateHistoryValidateBeforeCall(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion, queryPageReturned, queryReturnLimit, querySortField, querySortAscending, _callback);
        Type localVarReturnType = new TypeToken<List<ModelsPKICertificateOperation>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateCompareMetadata
     * @param certificateId Certificate identifier (required)
     * @param metadataFieldName Metadata field being compared (required)
     * @param value Value to compare against (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateCompareMetadataCall(Integer certificateId, String metadataFieldName, String value, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/Certificates/Metadata/Compare";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (certificateId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("certificateId", certificateId));
        }

        if (metadataFieldName != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("metadataFieldName", metadataFieldName));
        }

        if (value != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("value", value));
        }

        if (collectionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("collectionId", collectionId));
        }

        if (xKeyfactorApiVersion != null) {
            localVarHeaderParams.put("x-keyfactor-api-version", localVarApiClient.parameterToString(xKeyfactorApiVersion));
        }

        if (xKeyfactorRequestedWith != null) {
            localVarHeaderParams.put("x-keyfactor-requested-with", localVarApiClient.parameterToString(xKeyfactorRequestedWith));
        }

        final String[] localVarAccepts = {
            "application/json",
            "text/json",
            "application/xml",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateCompareMetadataValidateBeforeCall(Integer certificateId, String metadataFieldName, String value, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'certificateId' is set
        if (certificateId == null) {
            throw new ApiException("Missing the required parameter 'certificateId' when calling certificateCompareMetadata(Async)");
        }

        // verify the required parameter 'metadataFieldName' is set
        if (metadataFieldName == null) {
            throw new ApiException("Missing the required parameter 'metadataFieldName' when calling certificateCompareMetadata(Async)");
        }

        // verify the required parameter 'value' is set
        if (value == null) {
            throw new ApiException("Missing the required parameter 'value' when calling certificateCompareMetadata(Async)");
        }

        // verify the required parameter 'xKeyfactorRequestedWith' is set
        if (xKeyfactorRequestedWith == null) {
            throw new ApiException("Missing the required parameter 'xKeyfactorRequestedWith' when calling certificateCompareMetadata(Async)");
        }

        return certificateCompareMetadataCall(certificateId, metadataFieldName, value, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion, _callback);

    }

    /**
     * Compares the metadata value provided with the metadata value associated with the specified certificate
     * 
     * @param certificateId Certificate identifier (required)
     * @param metadataFieldName Metadata field being compared (required)
     * @param value Value to compare against (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return Boolean
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public Boolean certificateCompareMetadata(Integer certificateId, String metadataFieldName, String value, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        ApiResponse<Boolean> localVarResp = certificateCompareMetadataWithHttpInfo(certificateId, metadataFieldName, value, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion);
        return localVarResp.getData();
    }

    /**
     * Compares the metadata value provided with the metadata value associated with the specified certificate
     * 
     * @param certificateId Certificate identifier (required)
     * @param metadataFieldName Metadata field being compared (required)
     * @param value Value to compare against (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ApiResponse&lt;Boolean&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Boolean> certificateCompareMetadataWithHttpInfo(Integer certificateId, String metadataFieldName, String value, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        okhttp3.Call localVarCall = certificateCompareMetadataValidateBeforeCall(certificateId, metadataFieldName, value, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion, null);
        Type localVarReturnType = new TypeToken<Boolean>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Compares the metadata value provided with the metadata value associated with the specified certificate (asynchronously)
     * 
     * @param certificateId Certificate identifier (required)
     * @param metadataFieldName Metadata field being compared (required)
     * @param value Value to compare against (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateCompareMetadataAsync(Integer certificateId, String metadataFieldName, String value, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback<Boolean> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateCompareMetadataValidateBeforeCall(certificateId, metadataFieldName, value, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion, _callback);
        Type localVarReturnType = new TypeToken<Boolean>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateDeleteByQuery
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param sq Query by which certificates should be filtered for deletion (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateDeleteByQueryCall(String xKeyfactorRequestedWith, String sq, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = sq;

        // create path and map variables
        String localVarPath = "/Certificates/Query";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (collectionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("collectionId", collectionId));
        }

        if (xKeyfactorApiVersion != null) {
            localVarHeaderParams.put("x-keyfactor-api-version", localVarApiClient.parameterToString(xKeyfactorApiVersion));
        }

        if (xKeyfactorRequestedWith != null) {
            localVarHeaderParams.put("x-keyfactor-requested-with", localVarApiClient.parameterToString(xKeyfactorRequestedWith));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json",
            "text/json",
            "application/xml",
            "text/xml",
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateDeleteByQueryValidateBeforeCall(String xKeyfactorRequestedWith, String sq, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xKeyfactorRequestedWith' is set
        if (xKeyfactorRequestedWith == null) {
            throw new ApiException("Missing the required parameter 'xKeyfactorRequestedWith' when calling certificateDeleteByQuery(Async)");
        }

        // verify the required parameter 'sq' is set
        if (sq == null) {
            throw new ApiException("Missing the required parameter 'sq' when calling certificateDeleteByQuery(Async)");
        }

        return certificateDeleteByQueryCall(xKeyfactorRequestedWith, sq, collectionId, xKeyfactorApiVersion, _callback);

    }

    /**
     * Deletes multiple persisted certificate entities selected by a given query
     * This will ignore individual delete failures, and continue processing the array.
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param sq Query by which certificates should be filtered for deletion (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public void certificateDeleteByQuery(String xKeyfactorRequestedWith, String sq, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        certificateDeleteByQueryWithHttpInfo(xKeyfactorRequestedWith, sq, collectionId, xKeyfactorApiVersion);
    }

    /**
     * Deletes multiple persisted certificate entities selected by a given query
     * This will ignore individual delete failures, and continue processing the array.
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param sq Query by which certificates should be filtered for deletion (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> certificateDeleteByQueryWithHttpInfo(String xKeyfactorRequestedWith, String sq, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        okhttp3.Call localVarCall = certificateDeleteByQueryValidateBeforeCall(xKeyfactorRequestedWith, sq, collectionId, xKeyfactorApiVersion, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Deletes multiple persisted certificate entities selected by a given query (asynchronously)
     * This will ignore individual delete failures, and continue processing the array.
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param sq Query by which certificates should be filtered for deletion (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateDeleteByQueryAsync(String xKeyfactorRequestedWith, String sq, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateDeleteByQueryValidateBeforeCall(xKeyfactorRequestedWith, sq, collectionId, xKeyfactorApiVersion, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateDeleteCertificate
     * @param id Keyfactor identifier of the certificate record (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateDeleteCertificateCall(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/Certificates/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (collectionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("collectionId", collectionId));
        }

        if (xKeyfactorApiVersion != null) {
            localVarHeaderParams.put("x-keyfactor-api-version", localVarApiClient.parameterToString(xKeyfactorApiVersion));
        }

        if (xKeyfactorRequestedWith != null) {
            localVarHeaderParams.put("x-keyfactor-requested-with", localVarApiClient.parameterToString(xKeyfactorRequestedWith));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateDeleteCertificateValidateBeforeCall(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling certificateDeleteCertificate(Async)");
        }

        // verify the required parameter 'xKeyfactorRequestedWith' is set
        if (xKeyfactorRequestedWith == null) {
            throw new ApiException("Missing the required parameter 'xKeyfactorRequestedWith' when calling certificateDeleteCertificate(Async)");
        }

        return certificateDeleteCertificateCall(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion, _callback);

    }

    /**
     * Deletes a persisted certificate by its unique id as well as the stored private key (if present) associated with it
     * 
     * @param id Keyfactor identifier of the certificate record (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public void certificateDeleteCertificate(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        certificateDeleteCertificateWithHttpInfo(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion);
    }

    /**
     * Deletes a persisted certificate by its unique id as well as the stored private key (if present) associated with it
     * 
     * @param id Keyfactor identifier of the certificate record (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> certificateDeleteCertificateWithHttpInfo(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        okhttp3.Call localVarCall = certificateDeleteCertificateValidateBeforeCall(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Deletes a persisted certificate by its unique id as well as the stored private key (if present) associated with it (asynchronously)
     * 
     * @param id Keyfactor identifier of the certificate record (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateDeleteCertificateAsync(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateDeleteCertificateValidateBeforeCall(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateDeleteCertificates
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param ids The array of ids for certificate that are to be deleted (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateDeleteCertificatesCall(String xKeyfactorRequestedWith, List<Integer> ids, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = ids;

        // create path and map variables
        String localVarPath = "/Certificates";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (collectionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("collectionId", collectionId));
        }

        if (xKeyfactorApiVersion != null) {
            localVarHeaderParams.put("x-keyfactor-api-version", localVarApiClient.parameterToString(xKeyfactorApiVersion));
        }

        if (xKeyfactorRequestedWith != null) {
            localVarHeaderParams.put("x-keyfactor-requested-with", localVarApiClient.parameterToString(xKeyfactorRequestedWith));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json",
            "text/json",
            "application/xml",
            "text/xml",
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateDeleteCertificatesValidateBeforeCall(String xKeyfactorRequestedWith, List<Integer> ids, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xKeyfactorRequestedWith' is set
        if (xKeyfactorRequestedWith == null) {
            throw new ApiException("Missing the required parameter 'xKeyfactorRequestedWith' when calling certificateDeleteCertificates(Async)");
        }

        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling certificateDeleteCertificates(Async)");
        }

        return certificateDeleteCertificatesCall(xKeyfactorRequestedWith, ids, collectionId, xKeyfactorApiVersion, _callback);

    }

    /**
     * Deletes multiple persisted certificates by their unique ids
     * This will ignore individual delete failures, and continue processing the array
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param ids The array of ids for certificate that are to be deleted (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public void certificateDeleteCertificates(String xKeyfactorRequestedWith, List<Integer> ids, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        certificateDeleteCertificatesWithHttpInfo(xKeyfactorRequestedWith, ids, collectionId, xKeyfactorApiVersion);
    }

    /**
     * Deletes multiple persisted certificates by their unique ids
     * This will ignore individual delete failures, and continue processing the array
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param ids The array of ids for certificate that are to be deleted (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> certificateDeleteCertificatesWithHttpInfo(String xKeyfactorRequestedWith, List<Integer> ids, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        okhttp3.Call localVarCall = certificateDeleteCertificatesValidateBeforeCall(xKeyfactorRequestedWith, ids, collectionId, xKeyfactorApiVersion, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Deletes multiple persisted certificates by their unique ids (asynchronously)
     * This will ignore individual delete failures, and continue processing the array
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param ids The array of ids for certificate that are to be deleted (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateDeleteCertificatesAsync(String xKeyfactorRequestedWith, List<Integer> ids, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateDeleteCertificatesValidateBeforeCall(xKeyfactorRequestedWith, ids, collectionId, xKeyfactorApiVersion, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateDeletePrivateKeys0
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param ids Keyfactor identifiers of the cetficiates for which the associated private keys should be deleted (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateDeletePrivateKeys0Call(String xKeyfactorRequestedWith, List<Integer> ids, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = ids;

        // create path and map variables
        String localVarPath = "/Certificates/PrivateKey";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (collectionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("collectionId", collectionId));
        }

        if (xKeyfactorApiVersion != null) {
            localVarHeaderParams.put("x-keyfactor-api-version", localVarApiClient.parameterToString(xKeyfactorApiVersion));
        }

        if (xKeyfactorRequestedWith != null) {
            localVarHeaderParams.put("x-keyfactor-requested-with", localVarApiClient.parameterToString(xKeyfactorRequestedWith));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json",
            "text/json",
            "application/xml",
            "text/xml",
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateDeletePrivateKeys0ValidateBeforeCall(String xKeyfactorRequestedWith, List<Integer> ids, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xKeyfactorRequestedWith' is set
        if (xKeyfactorRequestedWith == null) {
            throw new ApiException("Missing the required parameter 'xKeyfactorRequestedWith' when calling certificateDeletePrivateKeys0(Async)");
        }

        // verify the required parameter 'ids' is set
        if (ids == null) {
            throw new ApiException("Missing the required parameter 'ids' when calling certificateDeletePrivateKeys0(Async)");
        }

        return certificateDeletePrivateKeys0Call(xKeyfactorRequestedWith, ids, collectionId, xKeyfactorApiVersion, _callback);

    }

    /**
     * Deletes the persisted private keys of multiple certificates by the unique ids of the Certificates
     * 
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param ids Keyfactor identifiers of the cetficiates for which the associated private keys should be deleted (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public void certificateDeletePrivateKeys0(String xKeyfactorRequestedWith, List<Integer> ids, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        certificateDeletePrivateKeys0WithHttpInfo(xKeyfactorRequestedWith, ids, collectionId, xKeyfactorApiVersion);
    }

    /**
     * Deletes the persisted private keys of multiple certificates by the unique ids of the Certificates
     * 
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param ids Keyfactor identifiers of the cetficiates for which the associated private keys should be deleted (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> certificateDeletePrivateKeys0WithHttpInfo(String xKeyfactorRequestedWith, List<Integer> ids, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        okhttp3.Call localVarCall = certificateDeletePrivateKeys0ValidateBeforeCall(xKeyfactorRequestedWith, ids, collectionId, xKeyfactorApiVersion, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Deletes the persisted private keys of multiple certificates by the unique ids of the Certificates (asynchronously)
     * 
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param ids Keyfactor identifiers of the cetficiates for which the associated private keys should be deleted (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateDeletePrivateKeys0Async(String xKeyfactorRequestedWith, List<Integer> ids, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateDeletePrivateKeys0ValidateBeforeCall(xKeyfactorRequestedWith, ids, collectionId, xKeyfactorApiVersion, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateDeletePrivateKeys1
     * @param id Keyfactor identifier of the certificate for which the associated private key should be deleted (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateDeletePrivateKeys1Call(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/Certificates/PrivateKey/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (collectionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("collectionId", collectionId));
        }

        if (xKeyfactorApiVersion != null) {
            localVarHeaderParams.put("x-keyfactor-api-version", localVarApiClient.parameterToString(xKeyfactorApiVersion));
        }

        if (xKeyfactorRequestedWith != null) {
            localVarHeaderParams.put("x-keyfactor-requested-with", localVarApiClient.parameterToString(xKeyfactorRequestedWith));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "DELETE", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateDeletePrivateKeys1ValidateBeforeCall(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling certificateDeletePrivateKeys1(Async)");
        }

        // verify the required parameter 'xKeyfactorRequestedWith' is set
        if (xKeyfactorRequestedWith == null) {
            throw new ApiException("Missing the required parameter 'xKeyfactorRequestedWith' when calling certificateDeletePrivateKeys1(Async)");
        }

        return certificateDeletePrivateKeys1Call(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion, _callback);

    }

    /**
     * Deletes the persisted private key of the certificate associated with the provided identifier
     * 
     * @param id Keyfactor identifier of the certificate for which the associated private key should be deleted (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public void certificateDeletePrivateKeys1(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        certificateDeletePrivateKeys1WithHttpInfo(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion);
    }

    /**
     * Deletes the persisted private key of the certificate associated with the provided identifier
     * 
     * @param id Keyfactor identifier of the certificate for which the associated private key should be deleted (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> certificateDeletePrivateKeys1WithHttpInfo(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        okhttp3.Call localVarCall = certificateDeletePrivateKeys1ValidateBeforeCall(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Deletes the persisted private key of the certificate associated with the provided identifier (asynchronously)
     * 
     * @param id Keyfactor identifier of the certificate for which the associated private key should be deleted (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateDeletePrivateKeys1Async(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateDeletePrivateKeys1ValidateBeforeCall(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateDownloadCertificateAsync
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param rq Query to filter the certificate to be recovered (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateDownloadCertificateAsyncCall(String xKeyfactorRequestedWith, ModelsCertificateDownloadRequest rq, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = rq;

        // create path and map variables
        String localVarPath = "/Certificates/Download";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (collectionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("collectionId", collectionId));
        }

        if (xKeyfactorApiVersion != null) {
            localVarHeaderParams.put("x-keyfactor-api-version", localVarApiClient.parameterToString(xKeyfactorApiVersion));
        }

        if (xKeyfactorRequestedWith != null) {
            localVarHeaderParams.put("x-keyfactor-requested-with", localVarApiClient.parameterToString(xKeyfactorRequestedWith));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateDownloadCertificateAsyncValidateBeforeCall(String xKeyfactorRequestedWith, ModelsCertificateDownloadRequest rq, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xKeyfactorRequestedWith' is set
        if (xKeyfactorRequestedWith == null) {
            throw new ApiException("Missing the required parameter 'xKeyfactorRequestedWith' when calling certificateDownloadCertificateAsync(Async)");
        }

        // verify the required parameter 'rq' is set
        if (rq == null) {
            throw new ApiException("Missing the required parameter 'rq' when calling certificateDownloadCertificateAsync(Async)");
        }

        return certificateDownloadCertificateAsyncCall(xKeyfactorRequestedWith, rq, collectionId, xKeyfactorApiVersion, _callback);

    }

    /**
     * Downloads the persisted certificate associated with the provided query
     * *NOTE: At least one of the following criteria must be provided:  1. Certificate ID  2. Thumbprint  3. Serial number AND Issuer DN (because Serial Number is CA-specific and so is not unique enough on its own)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param rq Query to filter the certificate to be recovered (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ModelsCertificateDownloadResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ModelsCertificateDownloadResponse certificateDownloadCertificateAsync(String xKeyfactorRequestedWith, ModelsCertificateDownloadRequest rq, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        ApiResponse<ModelsCertificateDownloadResponse> localVarResp = certificateDownloadCertificateAsyncWithHttpInfo(xKeyfactorRequestedWith, rq, collectionId, xKeyfactorApiVersion);
        return localVarResp.getData();
    }

    /**
     * Downloads the persisted certificate associated with the provided query
     * *NOTE: At least one of the following criteria must be provided:  1. Certificate ID  2. Thumbprint  3. Serial number AND Issuer DN (because Serial Number is CA-specific and so is not unique enough on its own)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param rq Query to filter the certificate to be recovered (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ApiResponse&lt;ModelsCertificateDownloadResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModelsCertificateDownloadResponse> certificateDownloadCertificateAsyncWithHttpInfo(String xKeyfactorRequestedWith, ModelsCertificateDownloadRequest rq, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        okhttp3.Call localVarCall = certificateDownloadCertificateAsyncValidateBeforeCall(xKeyfactorRequestedWith, rq, collectionId, xKeyfactorApiVersion, null);
        Type localVarReturnType = new TypeToken<ModelsCertificateDownloadResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Downloads the persisted certificate associated with the provided query (asynchronously)
     * *NOTE: At least one of the following criteria must be provided:  1. Certificate ID  2. Thumbprint  3. Serial number AND Issuer DN (because Serial Number is CA-specific and so is not unique enough on its own)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param rq Query to filter the certificate to be recovered (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateDownloadCertificateAsyncAsync(String xKeyfactorRequestedWith, ModelsCertificateDownloadRequest rq, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback<ModelsCertificateDownloadResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateDownloadCertificateAsyncValidateBeforeCall(xKeyfactorRequestedWith, rq, collectionId, xKeyfactorApiVersion, _callback);
        Type localVarReturnType = new TypeToken<ModelsCertificateDownloadResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateGetCertificate
     * @param id Keyfactor certificate identifier (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param includeLocations Include locations data for the certificate to be returned (optional)
     * @param includeMetadata Include metadata for the certificate to be returned (optional)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param verbose  (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateGetCertificateCall(Integer id, String xKeyfactorRequestedWith, Boolean includeLocations, Boolean includeMetadata, Integer collectionId, Integer verbose, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/Certificates/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (includeLocations != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeLocations", includeLocations));
        }

        if (includeMetadata != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeMetadata", includeMetadata));
        }

        if (collectionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("collectionId", collectionId));
        }

        if (verbose != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("verbose", verbose));
        }

        if (xKeyfactorApiVersion != null) {
            localVarHeaderParams.put("x-keyfactor-api-version", localVarApiClient.parameterToString(xKeyfactorApiVersion));
        }

        if (xKeyfactorRequestedWith != null) {
            localVarHeaderParams.put("x-keyfactor-requested-with", localVarApiClient.parameterToString(xKeyfactorRequestedWith));
        }

        final String[] localVarAccepts = {
            "application/json",
            "text/json",
            "application/xml",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateGetCertificateValidateBeforeCall(Integer id, String xKeyfactorRequestedWith, Boolean includeLocations, Boolean includeMetadata, Integer collectionId, Integer verbose, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling certificateGetCertificate(Async)");
        }

        // verify the required parameter 'xKeyfactorRequestedWith' is set
        if (xKeyfactorRequestedWith == null) {
            throw new ApiException("Missing the required parameter 'xKeyfactorRequestedWith' when calling certificateGetCertificate(Async)");
        }

        return certificateGetCertificateCall(id, xKeyfactorRequestedWith, includeLocations, includeMetadata, collectionId, verbose, xKeyfactorApiVersion, _callback);

    }

    /**
     * Returns a single certificate that matches the id
     * 
     * @param id Keyfactor certificate identifier (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param includeLocations Include locations data for the certificate to be returned (optional)
     * @param includeMetadata Include metadata for the certificate to be returned (optional)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param verbose  (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ModelsCertificateRetrievalResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ModelsCertificateRetrievalResponse certificateGetCertificate(Integer id, String xKeyfactorRequestedWith, Boolean includeLocations, Boolean includeMetadata, Integer collectionId, Integer verbose, String xKeyfactorApiVersion) throws ApiException {
        ApiResponse<ModelsCertificateRetrievalResponse> localVarResp = certificateGetCertificateWithHttpInfo(id, xKeyfactorRequestedWith, includeLocations, includeMetadata, collectionId, verbose, xKeyfactorApiVersion);
        return localVarResp.getData();
    }

    /**
     * Returns a single certificate that matches the id
     * 
     * @param id Keyfactor certificate identifier (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param includeLocations Include locations data for the certificate to be returned (optional)
     * @param includeMetadata Include metadata for the certificate to be returned (optional)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param verbose  (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ApiResponse&lt;ModelsCertificateRetrievalResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModelsCertificateRetrievalResponse> certificateGetCertificateWithHttpInfo(Integer id, String xKeyfactorRequestedWith, Boolean includeLocations, Boolean includeMetadata, Integer collectionId, Integer verbose, String xKeyfactorApiVersion) throws ApiException {
        okhttp3.Call localVarCall = certificateGetCertificateValidateBeforeCall(id, xKeyfactorRequestedWith, includeLocations, includeMetadata, collectionId, verbose, xKeyfactorApiVersion, null);
        Type localVarReturnType = new TypeToken<ModelsCertificateRetrievalResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Returns a single certificate that matches the id (asynchronously)
     * 
     * @param id Keyfactor certificate identifier (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param includeLocations Include locations data for the certificate to be returned (optional)
     * @param includeMetadata Include metadata for the certificate to be returned (optional)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param verbose  (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateGetCertificateAsync(Integer id, String xKeyfactorRequestedWith, Boolean includeLocations, Boolean includeMetadata, Integer collectionId, Integer verbose, String xKeyfactorApiVersion, final ApiCallback<ModelsCertificateRetrievalResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateGetCertificateValidateBeforeCall(id, xKeyfactorRequestedWith, includeLocations, includeMetadata, collectionId, verbose, xKeyfactorApiVersion, _callback);
        Type localVarReturnType = new TypeToken<ModelsCertificateRetrievalResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateGetCertificateLocations
     * @param id Keyfactor certificate identifier (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateGetCertificateLocationsCall(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/Certificates/Locations/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (collectionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("collectionId", collectionId));
        }

        if (xKeyfactorApiVersion != null) {
            localVarHeaderParams.put("x-keyfactor-api-version", localVarApiClient.parameterToString(xKeyfactorApiVersion));
        }

        if (xKeyfactorRequestedWith != null) {
            localVarHeaderParams.put("x-keyfactor-requested-with", localVarApiClient.parameterToString(xKeyfactorRequestedWith));
        }

        final String[] localVarAccepts = {
            "application/json",
            "text/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateGetCertificateLocationsValidateBeforeCall(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling certificateGetCertificateLocations(Async)");
        }

        // verify the required parameter 'xKeyfactorRequestedWith' is set
        if (xKeyfactorRequestedWith == null) {
            throw new ApiException("Missing the required parameter 'xKeyfactorRequestedWith' when calling certificateGetCertificateLocations(Async)");
        }

        return certificateGetCertificateLocationsCall(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion, _callback);

    }

    /**
     * Returns a list of locations the certificate is in
     * 
     * @param id Keyfactor certificate identifier (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return KeyfactorApiModelsCertificatesCertificateLocationsResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public KeyfactorApiModelsCertificatesCertificateLocationsResponse certificateGetCertificateLocations(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        ApiResponse<KeyfactorApiModelsCertificatesCertificateLocationsResponse> localVarResp = certificateGetCertificateLocationsWithHttpInfo(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion);
        return localVarResp.getData();
    }

    /**
     * Returns a list of locations the certificate is in
     * 
     * @param id Keyfactor certificate identifier (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ApiResponse&lt;KeyfactorApiModelsCertificatesCertificateLocationsResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<KeyfactorApiModelsCertificatesCertificateLocationsResponse> certificateGetCertificateLocationsWithHttpInfo(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        okhttp3.Call localVarCall = certificateGetCertificateLocationsValidateBeforeCall(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion, null);
        Type localVarReturnType = new TypeToken<KeyfactorApiModelsCertificatesCertificateLocationsResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Returns a list of locations the certificate is in (asynchronously)
     * 
     * @param id Keyfactor certificate identifier (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateGetCertificateLocationsAsync(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback<KeyfactorApiModelsCertificatesCertificateLocationsResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateGetCertificateLocationsValidateBeforeCall(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion, _callback);
        Type localVarReturnType = new TypeToken<KeyfactorApiModelsCertificatesCertificateLocationsResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateGetCertificateSecurity
     * @param id The Id of the certificate permissions are being checked on (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId The Id of the collection the certificate belongs in. Defaults to no collection (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateGetCertificateSecurityCall(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/Certificates/{id}/Security"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (collectionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("collectionId", collectionId));
        }

        if (xKeyfactorApiVersion != null) {
            localVarHeaderParams.put("x-keyfactor-api-version", localVarApiClient.parameterToString(xKeyfactorApiVersion));
        }

        if (xKeyfactorRequestedWith != null) {
            localVarHeaderParams.put("x-keyfactor-requested-with", localVarApiClient.parameterToString(xKeyfactorRequestedWith));
        }

        final String[] localVarAccepts = {
            "application/json",
            "text/json",
            "application/xml",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateGetCertificateSecurityValidateBeforeCall(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling certificateGetCertificateSecurity(Async)");
        }

        // verify the required parameter 'xKeyfactorRequestedWith' is set
        if (xKeyfactorRequestedWith == null) {
            throw new ApiException("Missing the required parameter 'xKeyfactorRequestedWith' when calling certificateGetCertificateSecurity(Async)");
        }

        return certificateGetCertificateSecurityCall(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion, _callback);

    }

    /**
     * Gets the list of Security Identities and which permissions they have on the given certificate.
     * 
     * @param id The Id of the certificate permissions are being checked on (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId The Id of the collection the certificate belongs in. Defaults to no collection (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ModelsSecurityCertificatePermissions
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ModelsSecurityCertificatePermissions certificateGetCertificateSecurity(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        ApiResponse<ModelsSecurityCertificatePermissions> localVarResp = certificateGetCertificateSecurityWithHttpInfo(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion);
        return localVarResp.getData();
    }

    /**
     * Gets the list of Security Identities and which permissions they have on the given certificate.
     * 
     * @param id The Id of the certificate permissions are being checked on (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId The Id of the collection the certificate belongs in. Defaults to no collection (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ApiResponse&lt;ModelsSecurityCertificatePermissions&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModelsSecurityCertificatePermissions> certificateGetCertificateSecurityWithHttpInfo(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        okhttp3.Call localVarCall = certificateGetCertificateSecurityValidateBeforeCall(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion, null);
        Type localVarReturnType = new TypeToken<ModelsSecurityCertificatePermissions>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Gets the list of Security Identities and which permissions they have on the given certificate. (asynchronously)
     * 
     * @param id The Id of the certificate permissions are being checked on (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId The Id of the collection the certificate belongs in. Defaults to no collection (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateGetCertificateSecurityAsync(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback<ModelsSecurityCertificatePermissions> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateGetCertificateSecurityValidateBeforeCall(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion, _callback);
        Type localVarReturnType = new TypeToken<ModelsSecurityCertificatePermissions>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateIdentityAudit
     * @param id The Id of the certificate being checked (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId An optional parameter for the collectin Id the certificate is in.  Defaults to no collection (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateIdentityAuditCall(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/Certificates/IdentityAudit/{id}"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (collectionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("collectionId", collectionId));
        }

        if (xKeyfactorApiVersion != null) {
            localVarHeaderParams.put("x-keyfactor-api-version", localVarApiClient.parameterToString(xKeyfactorApiVersion));
        }

        if (xKeyfactorRequestedWith != null) {
            localVarHeaderParams.put("x-keyfactor-requested-with", localVarApiClient.parameterToString(xKeyfactorRequestedWith));
        }

        final String[] localVarAccepts = {
            "application/json",
            "text/json",
            "application/xml",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateIdentityAuditValidateBeforeCall(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling certificateIdentityAudit(Async)");
        }

        // verify the required parameter 'xKeyfactorRequestedWith' is set
        if (xKeyfactorRequestedWith == null) {
            throw new ApiException("Missing the required parameter 'xKeyfactorRequestedWith' when calling certificateIdentityAudit(Async)");
        }

        return certificateIdentityAuditCall(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion, _callback);

    }

    /**
     * Audit identity permissions for certificate
     * 
     * @param id The Id of the certificate being checked (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId An optional parameter for the collectin Id the certificate is in.  Defaults to no collection (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return List&lt;KeyfactorApiModelsCertificatesCertificateIdentityAuditResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<KeyfactorApiModelsCertificatesCertificateIdentityAuditResponse> certificateIdentityAudit(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        ApiResponse<List<KeyfactorApiModelsCertificatesCertificateIdentityAuditResponse>> localVarResp = certificateIdentityAuditWithHttpInfo(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion);
        return localVarResp.getData();
    }

    /**
     * Audit identity permissions for certificate
     * 
     * @param id The Id of the certificate being checked (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId An optional parameter for the collectin Id the certificate is in.  Defaults to no collection (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ApiResponse&lt;List&lt;KeyfactorApiModelsCertificatesCertificateIdentityAuditResponse&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<KeyfactorApiModelsCertificatesCertificateIdentityAuditResponse>> certificateIdentityAuditWithHttpInfo(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        okhttp3.Call localVarCall = certificateIdentityAuditValidateBeforeCall(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion, null);
        Type localVarReturnType = new TypeToken<List<KeyfactorApiModelsCertificatesCertificateIdentityAuditResponse>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Audit identity permissions for certificate (asynchronously)
     * 
     * @param id The Id of the certificate being checked (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId An optional parameter for the collectin Id the certificate is in.  Defaults to no collection (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateIdentityAuditAsync(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback<List<KeyfactorApiModelsCertificatesCertificateIdentityAuditResponse>> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateIdentityAuditValidateBeforeCall(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion, _callback);
        Type localVarReturnType = new TypeToken<List<KeyfactorApiModelsCertificatesCertificateIdentityAuditResponse>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificatePostImportCertificate
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param req Request containing the base 64 encoded string and related certificate information, such as certificate stores, metadata, and password (required)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificatePostImportCertificateCall(String xKeyfactorRequestedWith, ModelsCertificateImportRequestModel req, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = req;

        // create path and map variables
        String localVarPath = "/Certificates/Import";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xKeyfactorApiVersion != null) {
            localVarHeaderParams.put("x-keyfactor-api-version", localVarApiClient.parameterToString(xKeyfactorApiVersion));
        }

        if (xKeyfactorRequestedWith != null) {
            localVarHeaderParams.put("x-keyfactor-requested-with", localVarApiClient.parameterToString(xKeyfactorRequestedWith));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificatePostImportCertificateValidateBeforeCall(String xKeyfactorRequestedWith, ModelsCertificateImportRequestModel req, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xKeyfactorRequestedWith' is set
        if (xKeyfactorRequestedWith == null) {
            throw new ApiException("Missing the required parameter 'xKeyfactorRequestedWith' when calling certificatePostImportCertificate(Async)");
        }

        // verify the required parameter 'req' is set
        if (req == null) {
            throw new ApiException("Missing the required parameter 'req' when calling certificatePostImportCertificate(Async)");
        }

        return certificatePostImportCertificateCall(xKeyfactorRequestedWith, req, xKeyfactorApiVersion, _callback);

    }

    /**
     * Imports the provided certificate into the Keyfactor instance, including any provided associated data
     * 
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param req Request containing the base 64 encoded string and related certificate information, such as certificate stores, metadata, and password (required)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ModelsCertificateImportResponseModel
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ModelsCertificateImportResponseModel certificatePostImportCertificate(String xKeyfactorRequestedWith, ModelsCertificateImportRequestModel req, String xKeyfactorApiVersion) throws ApiException {
        ApiResponse<ModelsCertificateImportResponseModel> localVarResp = certificatePostImportCertificateWithHttpInfo(xKeyfactorRequestedWith, req, xKeyfactorApiVersion);
        return localVarResp.getData();
    }

    /**
     * Imports the provided certificate into the Keyfactor instance, including any provided associated data
     * 
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param req Request containing the base 64 encoded string and related certificate information, such as certificate stores, metadata, and password (required)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ApiResponse&lt;ModelsCertificateImportResponseModel&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModelsCertificateImportResponseModel> certificatePostImportCertificateWithHttpInfo(String xKeyfactorRequestedWith, ModelsCertificateImportRequestModel req, String xKeyfactorApiVersion) throws ApiException {
        okhttp3.Call localVarCall = certificatePostImportCertificateValidateBeforeCall(xKeyfactorRequestedWith, req, xKeyfactorApiVersion, null);
        Type localVarReturnType = new TypeToken<ModelsCertificateImportResponseModel>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Imports the provided certificate into the Keyfactor instance, including any provided associated data (asynchronously)
     * 
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param req Request containing the base 64 encoded string and related certificate information, such as certificate stores, metadata, and password (required)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificatePostImportCertificateAsync(String xKeyfactorRequestedWith, ModelsCertificateImportRequestModel req, String xKeyfactorApiVersion, final ApiCallback<ModelsCertificateImportResponseModel> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificatePostImportCertificateValidateBeforeCall(xKeyfactorRequestedWith, req, xKeyfactorApiVersion, _callback);
        Type localVarReturnType = new TypeToken<ModelsCertificateImportResponseModel>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateQueryCertificates
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param includeLocations Include locations data for the certificates to be returned (optional)
     * @param includeMetadata Include metadata for the certificates to be returned (optional)
     * @param includeHasPrivateKey Include whether the certificates to be returned have private keys stored in the Keyfactor database (optional)
     * @param verbose  (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param pqQueryString Contents of the query (ex: field1 -eq value1 AND field2 -gt value2) (optional)
     * @param pqPageReturned The current page within the result set to be returned (optional)
     * @param pqReturnLimit Maximum number of records to be returned in a single call (optional)
     * @param pqSortField Field by which the results should be sorted (view results via Management Portal for sortable columns) (optional)
     * @param pqSortAscending Field sort direction [0&#x3D;ascending, 1&#x3D;descending] (optional)
     * @param pqIncludeRevoked Select &#39;true&#39; to include revoked certificates in the results (optional)
     * @param pqIncludeExpired Select &#39;true&#39; to include expired certificates in the results (optional)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateQueryCertificatesCall(String xKeyfactorRequestedWith, Integer collectionId, Boolean includeLocations, Boolean includeMetadata, Boolean includeHasPrivateKey, Integer verbose, String xKeyfactorApiVersion, String pqQueryString, Integer pqPageReturned, Integer pqReturnLimit, String pqSortField, Integer pqSortAscending, Boolean pqIncludeRevoked, Boolean pqIncludeExpired, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/Certificates";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (collectionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("collectionId", collectionId));
        }

        if (includeLocations != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeLocations", includeLocations));
        }

        if (includeMetadata != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeMetadata", includeMetadata));
        }

        if (includeHasPrivateKey != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("includeHasPrivateKey", includeHasPrivateKey));
        }

        if (verbose != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("verbose", verbose));
        }

        if (pqQueryString != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pq.queryString", pqQueryString));
        }

        if (pqPageReturned != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pq.pageReturned", pqPageReturned));
        }

        if (pqReturnLimit != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pq.returnLimit", pqReturnLimit));
        }

        if (pqSortField != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pq.sortField", pqSortField));
        }

        if (pqSortAscending != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pq.sortAscending", pqSortAscending));
        }

        if (pqIncludeRevoked != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pq.includeRevoked", pqIncludeRevoked));
        }

        if (pqIncludeExpired != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("pq.includeExpired", pqIncludeExpired));
        }

        if (xKeyfactorApiVersion != null) {
            localVarHeaderParams.put("x-keyfactor-api-version", localVarApiClient.parameterToString(xKeyfactorApiVersion));
        }

        if (xKeyfactorRequestedWith != null) {
            localVarHeaderParams.put("x-keyfactor-requested-with", localVarApiClient.parameterToString(xKeyfactorRequestedWith));
        }

        final String[] localVarAccepts = {
            "application/json",
            "text/json",
            "application/xml",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateQueryCertificatesValidateBeforeCall(String xKeyfactorRequestedWith, Integer collectionId, Boolean includeLocations, Boolean includeMetadata, Boolean includeHasPrivateKey, Integer verbose, String xKeyfactorApiVersion, String pqQueryString, Integer pqPageReturned, Integer pqReturnLimit, String pqSortField, Integer pqSortAscending, Boolean pqIncludeRevoked, Boolean pqIncludeExpired, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xKeyfactorRequestedWith' is set
        if (xKeyfactorRequestedWith == null) {
            throw new ApiException("Missing the required parameter 'xKeyfactorRequestedWith' when calling certificateQueryCertificates(Async)");
        }

        return certificateQueryCertificatesCall(xKeyfactorRequestedWith, collectionId, includeLocations, includeMetadata, includeHasPrivateKey, verbose, xKeyfactorApiVersion, pqQueryString, pqPageReturned, pqReturnLimit, pqSortField, pqSortAscending, pqIncludeRevoked, pqIncludeExpired, _callback);

    }

    /**
     * Returns all certificates according to the provided filter and output parameters
     * 
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param includeLocations Include locations data for the certificates to be returned (optional)
     * @param includeMetadata Include metadata for the certificates to be returned (optional)
     * @param includeHasPrivateKey Include whether the certificates to be returned have private keys stored in the Keyfactor database (optional)
     * @param verbose  (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param pqQueryString Contents of the query (ex: field1 -eq value1 AND field2 -gt value2) (optional)
     * @param pqPageReturned The current page within the result set to be returned (optional)
     * @param pqReturnLimit Maximum number of records to be returned in a single call (optional)
     * @param pqSortField Field by which the results should be sorted (view results via Management Portal for sortable columns) (optional)
     * @param pqSortAscending Field sort direction [0&#x3D;ascending, 1&#x3D;descending] (optional)
     * @param pqIncludeRevoked Select &#39;true&#39; to include revoked certificates in the results (optional)
     * @param pqIncludeExpired Select &#39;true&#39; to include expired certificates in the results (optional)
     * @return List&lt;ModelsCertificateRetrievalResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public List<ModelsCertificateRetrievalResponse> certificateQueryCertificates(String xKeyfactorRequestedWith, Integer collectionId, Boolean includeLocations, Boolean includeMetadata, Boolean includeHasPrivateKey, Integer verbose, String xKeyfactorApiVersion, String pqQueryString, Integer pqPageReturned, Integer pqReturnLimit, String pqSortField, Integer pqSortAscending, Boolean pqIncludeRevoked, Boolean pqIncludeExpired) throws ApiException {
        ApiResponse<List<ModelsCertificateRetrievalResponse>> localVarResp = certificateQueryCertificatesWithHttpInfo(xKeyfactorRequestedWith, collectionId, includeLocations, includeMetadata, includeHasPrivateKey, verbose, xKeyfactorApiVersion, pqQueryString, pqPageReturned, pqReturnLimit, pqSortField, pqSortAscending, pqIncludeRevoked, pqIncludeExpired);
        return localVarResp.getData();
    }

    /**
     * Returns all certificates according to the provided filter and output parameters
     * 
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param includeLocations Include locations data for the certificates to be returned (optional)
     * @param includeMetadata Include metadata for the certificates to be returned (optional)
     * @param includeHasPrivateKey Include whether the certificates to be returned have private keys stored in the Keyfactor database (optional)
     * @param verbose  (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param pqQueryString Contents of the query (ex: field1 -eq value1 AND field2 -gt value2) (optional)
     * @param pqPageReturned The current page within the result set to be returned (optional)
     * @param pqReturnLimit Maximum number of records to be returned in a single call (optional)
     * @param pqSortField Field by which the results should be sorted (view results via Management Portal for sortable columns) (optional)
     * @param pqSortAscending Field sort direction [0&#x3D;ascending, 1&#x3D;descending] (optional)
     * @param pqIncludeRevoked Select &#39;true&#39; to include revoked certificates in the results (optional)
     * @param pqIncludeExpired Select &#39;true&#39; to include expired certificates in the results (optional)
     * @return ApiResponse&lt;List&lt;ModelsCertificateRetrievalResponse&gt;&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<List<ModelsCertificateRetrievalResponse>> certificateQueryCertificatesWithHttpInfo(String xKeyfactorRequestedWith, Integer collectionId, Boolean includeLocations, Boolean includeMetadata, Boolean includeHasPrivateKey, Integer verbose, String xKeyfactorApiVersion, String pqQueryString, Integer pqPageReturned, Integer pqReturnLimit, String pqSortField, Integer pqSortAscending, Boolean pqIncludeRevoked, Boolean pqIncludeExpired) throws ApiException {
        okhttp3.Call localVarCall = certificateQueryCertificatesValidateBeforeCall(xKeyfactorRequestedWith, collectionId, includeLocations, includeMetadata, includeHasPrivateKey, verbose, xKeyfactorApiVersion, pqQueryString, pqPageReturned, pqReturnLimit, pqSortField, pqSortAscending, pqIncludeRevoked, pqIncludeExpired, null);
        Type localVarReturnType = new TypeToken<List<ModelsCertificateRetrievalResponse>>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Returns all certificates according to the provided filter and output parameters (asynchronously)
     * 
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param includeLocations Include locations data for the certificates to be returned (optional)
     * @param includeMetadata Include metadata for the certificates to be returned (optional)
     * @param includeHasPrivateKey Include whether the certificates to be returned have private keys stored in the Keyfactor database (optional)
     * @param verbose  (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param pqQueryString Contents of the query (ex: field1 -eq value1 AND field2 -gt value2) (optional)
     * @param pqPageReturned The current page within the result set to be returned (optional)
     * @param pqReturnLimit Maximum number of records to be returned in a single call (optional)
     * @param pqSortField Field by which the results should be sorted (view results via Management Portal for sortable columns) (optional)
     * @param pqSortAscending Field sort direction [0&#x3D;ascending, 1&#x3D;descending] (optional)
     * @param pqIncludeRevoked Select &#39;true&#39; to include revoked certificates in the results (optional)
     * @param pqIncludeExpired Select &#39;true&#39; to include expired certificates in the results (optional)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateQueryCertificatesAsync(String xKeyfactorRequestedWith, Integer collectionId, Boolean includeLocations, Boolean includeMetadata, Boolean includeHasPrivateKey, Integer verbose, String xKeyfactorApiVersion, String pqQueryString, Integer pqPageReturned, Integer pqReturnLimit, String pqSortField, Integer pqSortAscending, Boolean pqIncludeRevoked, Boolean pqIncludeExpired, final ApiCallback<List<ModelsCertificateRetrievalResponse>> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateQueryCertificatesValidateBeforeCall(xKeyfactorRequestedWith, collectionId, includeLocations, includeMetadata, includeHasPrivateKey, verbose, xKeyfactorApiVersion, pqQueryString, pqPageReturned, pqReturnLimit, pqSortField, pqSortAscending, pqIncludeRevoked, pqIncludeExpired, _callback);
        Type localVarReturnType = new TypeToken<List<ModelsCertificateRetrievalResponse>>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateRecoverCertificateAsync
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param rq Query to filter the certificate to be recovered (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateRecoverCertificateAsyncCall(String xKeyfactorRequestedWith, ModelsCertificateRecoveryRequest rq, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = rq;

        // create path and map variables
        String localVarPath = "/Certificates/Recover";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (collectionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("collectionId", collectionId));
        }

        if (xKeyfactorApiVersion != null) {
            localVarHeaderParams.put("x-keyfactor-api-version", localVarApiClient.parameterToString(xKeyfactorApiVersion));
        }

        if (xKeyfactorRequestedWith != null) {
            localVarHeaderParams.put("x-keyfactor-requested-with", localVarApiClient.parameterToString(xKeyfactorRequestedWith));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateRecoverCertificateAsyncValidateBeforeCall(String xKeyfactorRequestedWith, ModelsCertificateRecoveryRequest rq, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xKeyfactorRequestedWith' is set
        if (xKeyfactorRequestedWith == null) {
            throw new ApiException("Missing the required parameter 'xKeyfactorRequestedWith' when calling certificateRecoverCertificateAsync(Async)");
        }

        // verify the required parameter 'rq' is set
        if (rq == null) {
            throw new ApiException("Missing the required parameter 'rq' when calling certificateRecoverCertificateAsync(Async)");
        }

        return certificateRecoverCertificateAsyncCall(xKeyfactorRequestedWith, rq, collectionId, xKeyfactorApiVersion, _callback);

    }

    /**
     * Recovers the persisted certificate associated with the provided query
     * *NOTE: At least one of the following criteria must be provided:  1. Certificate ID  2. Thumbprint  3. Serial number AND Issuer DN (because Serial Number is CA-specific and so is not unique enough on its own)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param rq Query to filter the certificate to be recovered (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ModelsRecoveryResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ModelsRecoveryResponse certificateRecoverCertificateAsync(String xKeyfactorRequestedWith, ModelsCertificateRecoveryRequest rq, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        ApiResponse<ModelsRecoveryResponse> localVarResp = certificateRecoverCertificateAsyncWithHttpInfo(xKeyfactorRequestedWith, rq, collectionId, xKeyfactorApiVersion);
        return localVarResp.getData();
    }

    /**
     * Recovers the persisted certificate associated with the provided query
     * *NOTE: At least one of the following criteria must be provided:  1. Certificate ID  2. Thumbprint  3. Serial number AND Issuer DN (because Serial Number is CA-specific and so is not unique enough on its own)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param rq Query to filter the certificate to be recovered (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ApiResponse&lt;ModelsRecoveryResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModelsRecoveryResponse> certificateRecoverCertificateAsyncWithHttpInfo(String xKeyfactorRequestedWith, ModelsCertificateRecoveryRequest rq, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        okhttp3.Call localVarCall = certificateRecoverCertificateAsyncValidateBeforeCall(xKeyfactorRequestedWith, rq, collectionId, xKeyfactorApiVersion, null);
        Type localVarReturnType = new TypeToken<ModelsRecoveryResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Recovers the persisted certificate associated with the provided query (asynchronously)
     * *NOTE: At least one of the following criteria must be provided:  1. Certificate ID  2. Thumbprint  3. Serial number AND Issuer DN (because Serial Number is CA-specific and so is not unique enough on its own)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param rq Query to filter the certificate to be recovered (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateRecoverCertificateAsyncAsync(String xKeyfactorRequestedWith, ModelsCertificateRecoveryRequest rq, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback<ModelsRecoveryResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateRecoverCertificateAsyncValidateBeforeCall(xKeyfactorRequestedWith, rq, collectionId, xKeyfactorApiVersion, _callback);
        Type localVarReturnType = new TypeToken<ModelsRecoveryResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateRevoke
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param request Contains the Keyfactor certificate identifiers and revocation data (required)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateRevokeCall(String xKeyfactorRequestedWith, ModelsRevokeCertificateRequest request, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = request;

        // create path and map variables
        String localVarPath = "/Certificates/Revoke";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (xKeyfactorApiVersion != null) {
            localVarHeaderParams.put("x-keyfactor-api-version", localVarApiClient.parameterToString(xKeyfactorApiVersion));
        }

        if (xKeyfactorRequestedWith != null) {
            localVarHeaderParams.put("x-keyfactor-requested-with", localVarApiClient.parameterToString(xKeyfactorRequestedWith));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateRevokeValidateBeforeCall(String xKeyfactorRequestedWith, ModelsRevokeCertificateRequest request, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xKeyfactorRequestedWith' is set
        if (xKeyfactorRequestedWith == null) {
            throw new ApiException("Missing the required parameter 'xKeyfactorRequestedWith' when calling certificateRevoke(Async)");
        }

        // verify the required parameter 'request' is set
        if (request == null) {
            throw new ApiException("Missing the required parameter 'request' when calling certificateRevoke(Async)");
        }

        return certificateRevokeCall(xKeyfactorRequestedWith, request, xKeyfactorApiVersion, _callback);

    }

    /**
     * Revokes the certificates associated with the provided identifiers and associates the provided data with the revocation
     * ### Revocation Reason Codes for Microsoft CA ###  | Value             | Description               |  |-------------------|---------------------------|  | -1                | Remove from hold          |  | 0                 | Unspecified               |  | 1                 | Key compromised           |  | 2                 | CA compromised            |  | 3                 | Affiliation changed       |  | 4                 | Superceded                |  | 5                 | Cessation of operation    |  | 6                 | Certificate hold          |  | 7                 | Remove from CRL           |  | 999               | Unknown                   |
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param request Contains the Keyfactor certificate identifiers and revocation data (required)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ModelsRevocationRevocationResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ModelsRevocationRevocationResponse certificateRevoke(String xKeyfactorRequestedWith, ModelsRevokeCertificateRequest request, String xKeyfactorApiVersion) throws ApiException {
        ApiResponse<ModelsRevocationRevocationResponse> localVarResp = certificateRevokeWithHttpInfo(xKeyfactorRequestedWith, request, xKeyfactorApiVersion);
        return localVarResp.getData();
    }

    /**
     * Revokes the certificates associated with the provided identifiers and associates the provided data with the revocation
     * ### Revocation Reason Codes for Microsoft CA ###  | Value             | Description               |  |-------------------|---------------------------|  | -1                | Remove from hold          |  | 0                 | Unspecified               |  | 1                 | Key compromised           |  | 2                 | CA compromised            |  | 3                 | Affiliation changed       |  | 4                 | Superceded                |  | 5                 | Cessation of operation    |  | 6                 | Certificate hold          |  | 7                 | Remove from CRL           |  | 999               | Unknown                   |
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param request Contains the Keyfactor certificate identifiers and revocation data (required)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ApiResponse&lt;ModelsRevocationRevocationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModelsRevocationRevocationResponse> certificateRevokeWithHttpInfo(String xKeyfactorRequestedWith, ModelsRevokeCertificateRequest request, String xKeyfactorApiVersion) throws ApiException {
        okhttp3.Call localVarCall = certificateRevokeValidateBeforeCall(xKeyfactorRequestedWith, request, xKeyfactorApiVersion, null);
        Type localVarReturnType = new TypeToken<ModelsRevocationRevocationResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Revokes the certificates associated with the provided identifiers and associates the provided data with the revocation (asynchronously)
     * ### Revocation Reason Codes for Microsoft CA ###  | Value             | Description               |  |-------------------|---------------------------|  | -1                | Remove from hold          |  | 0                 | Unspecified               |  | 1                 | Key compromised           |  | 2                 | CA compromised            |  | 3                 | Affiliation changed       |  | 4                 | Superceded                |  | 5                 | Cessation of operation    |  | 6                 | Certificate hold          |  | 7                 | Remove from CRL           |  | 999               | Unknown                   |
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param request Contains the Keyfactor certificate identifiers and revocation data (required)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateRevokeAsync(String xKeyfactorRequestedWith, ModelsRevokeCertificateRequest request, String xKeyfactorApiVersion, final ApiCallback<ModelsRevocationRevocationResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateRevokeValidateBeforeCall(xKeyfactorRequestedWith, request, xKeyfactorApiVersion, _callback);
        Type localVarReturnType = new TypeToken<ModelsRevocationRevocationResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateRevokeAll
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param request Contains the Keyfactor Query and revocation data (required)
     * @param collectionId A collection Id to be used for permissions and part of the query to revoke certificates (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateRevokeAllCall(String xKeyfactorRequestedWith, ModelsRevokeAllCertificatesRequest request, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = request;

        // create path and map variables
        String localVarPath = "/Certificates/RevokeAll";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (collectionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("collectionId", collectionId));
        }

        if (xKeyfactorApiVersion != null) {
            localVarHeaderParams.put("x-keyfactor-api-version", localVarApiClient.parameterToString(xKeyfactorApiVersion));
        }

        if (xKeyfactorRequestedWith != null) {
            localVarHeaderParams.put("x-keyfactor-requested-with", localVarApiClient.parameterToString(xKeyfactorRequestedWith));
        }

        final String[] localVarAccepts = {
            "application/json"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "POST", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateRevokeAllValidateBeforeCall(String xKeyfactorRequestedWith, ModelsRevokeAllCertificatesRequest request, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xKeyfactorRequestedWith' is set
        if (xKeyfactorRequestedWith == null) {
            throw new ApiException("Missing the required parameter 'xKeyfactorRequestedWith' when calling certificateRevokeAll(Async)");
        }

        // verify the required parameter 'request' is set
        if (request == null) {
            throw new ApiException("Missing the required parameter 'request' when calling certificateRevokeAll(Async)");
        }

        return certificateRevokeAllCall(xKeyfactorRequestedWith, request, collectionId, xKeyfactorApiVersion, _callback);

    }

    /**
     * Revokes the certificates associated with the provided query and Collection Id and associates the provided data with the revocation
     * ### Revocation Reason Codes for Microsoft CA ###  | Value             | Description              |  |-------------------|--------------------------|  | -1                | Remove from hold         |  | 0                 | Unspecified              |  | 1                 | Key compromised          |  | 2                 | CA compromised           |  | 3                 | Affiliation changed      |  | 4                 | Superceded               |  | 5                 | Cessation of operation   |  | 6                 | Certificate hold         |  | 7                 | Remove from CRL          |  | 999               | Unknown                  |
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param request Contains the Keyfactor Query and revocation data (required)
     * @param collectionId A collection Id to be used for permissions and part of the query to revoke certificates (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ModelsRevocationRevocationResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ModelsRevocationRevocationResponse certificateRevokeAll(String xKeyfactorRequestedWith, ModelsRevokeAllCertificatesRequest request, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        ApiResponse<ModelsRevocationRevocationResponse> localVarResp = certificateRevokeAllWithHttpInfo(xKeyfactorRequestedWith, request, collectionId, xKeyfactorApiVersion);
        return localVarResp.getData();
    }

    /**
     * Revokes the certificates associated with the provided query and Collection Id and associates the provided data with the revocation
     * ### Revocation Reason Codes for Microsoft CA ###  | Value             | Description              |  |-------------------|--------------------------|  | -1                | Remove from hold         |  | 0                 | Unspecified              |  | 1                 | Key compromised          |  | 2                 | CA compromised           |  | 3                 | Affiliation changed      |  | 4                 | Superceded               |  | 5                 | Cessation of operation   |  | 6                 | Certificate hold         |  | 7                 | Remove from CRL          |  | 999               | Unknown                  |
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param request Contains the Keyfactor Query and revocation data (required)
     * @param collectionId A collection Id to be used for permissions and part of the query to revoke certificates (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ApiResponse&lt;ModelsRevocationRevocationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModelsRevocationRevocationResponse> certificateRevokeAllWithHttpInfo(String xKeyfactorRequestedWith, ModelsRevokeAllCertificatesRequest request, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        okhttp3.Call localVarCall = certificateRevokeAllValidateBeforeCall(xKeyfactorRequestedWith, request, collectionId, xKeyfactorApiVersion, null);
        Type localVarReturnType = new TypeToken<ModelsRevocationRevocationResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Revokes the certificates associated with the provided query and Collection Id and associates the provided data with the revocation (asynchronously)
     * ### Revocation Reason Codes for Microsoft CA ###  | Value             | Description              |  |-------------------|--------------------------|  | -1                | Remove from hold         |  | 0                 | Unspecified              |  | 1                 | Key compromised          |  | 2                 | CA compromised           |  | 3                 | Affiliation changed      |  | 4                 | Superceded               |  | 5                 | Cessation of operation   |  | 6                 | Certificate hold         |  | 7                 | Remove from CRL          |  | 999               | Unknown                  |
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param request Contains the Keyfactor Query and revocation data (required)
     * @param collectionId A collection Id to be used for permissions and part of the query to revoke certificates (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateRevokeAllAsync(String xKeyfactorRequestedWith, ModelsRevokeAllCertificatesRequest request, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback<ModelsRevocationRevocationResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateRevokeAllValidateBeforeCall(xKeyfactorRequestedWith, request, collectionId, xKeyfactorApiVersion, _callback);
        Type localVarReturnType = new TypeToken<ModelsRevocationRevocationResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateUpdateAllMetadata
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param metadataUpdate Contains the Keyfactor certificate identifier and the metadata to be updated (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateUpdateAllMetadataCall(String xKeyfactorRequestedWith, ModelsMetadataAllUpdateRequest metadataUpdate, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = metadataUpdate;

        // create path and map variables
        String localVarPath = "/Certificates/Metadata/All";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (collectionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("collectionId", collectionId));
        }

        if (xKeyfactorApiVersion != null) {
            localVarHeaderParams.put("x-keyfactor-api-version", localVarApiClient.parameterToString(xKeyfactorApiVersion));
        }

        if (xKeyfactorRequestedWith != null) {
            localVarHeaderParams.put("x-keyfactor-requested-with", localVarApiClient.parameterToString(xKeyfactorRequestedWith));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json",
            "text/json",
            "application/xml",
            "text/xml",
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateUpdateAllMetadataValidateBeforeCall(String xKeyfactorRequestedWith, ModelsMetadataAllUpdateRequest metadataUpdate, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xKeyfactorRequestedWith' is set
        if (xKeyfactorRequestedWith == null) {
            throw new ApiException("Missing the required parameter 'xKeyfactorRequestedWith' when calling certificateUpdateAllMetadata(Async)");
        }

        // verify the required parameter 'metadataUpdate' is set
        if (metadataUpdate == null) {
            throw new ApiException("Missing the required parameter 'metadataUpdate' when calling certificateUpdateAllMetadata(Async)");
        }

        return certificateUpdateAllMetadataCall(xKeyfactorRequestedWith, metadataUpdate, collectionId, xKeyfactorApiVersion, _callback);

    }

    /**
     * Updates the metadata for certificates associated with the certificate identifiers or query provided
     * 
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param metadataUpdate Contains the Keyfactor certificate identifier and the metadata to be updated (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public void certificateUpdateAllMetadata(String xKeyfactorRequestedWith, ModelsMetadataAllUpdateRequest metadataUpdate, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        certificateUpdateAllMetadataWithHttpInfo(xKeyfactorRequestedWith, metadataUpdate, collectionId, xKeyfactorApiVersion);
    }

    /**
     * Updates the metadata for certificates associated with the certificate identifiers or query provided
     * 
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param metadataUpdate Contains the Keyfactor certificate identifier and the metadata to be updated (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> certificateUpdateAllMetadataWithHttpInfo(String xKeyfactorRequestedWith, ModelsMetadataAllUpdateRequest metadataUpdate, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        okhttp3.Call localVarCall = certificateUpdateAllMetadataValidateBeforeCall(xKeyfactorRequestedWith, metadataUpdate, collectionId, xKeyfactorApiVersion, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Updates the metadata for certificates associated with the certificate identifiers or query provided (asynchronously)
     * 
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param metadataUpdate Contains the Keyfactor certificate identifier and the metadata to be updated (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateUpdateAllMetadataAsync(String xKeyfactorRequestedWith, ModelsMetadataAllUpdateRequest metadataUpdate, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateUpdateAllMetadataValidateBeforeCall(xKeyfactorRequestedWith, metadataUpdate, collectionId, xKeyfactorApiVersion, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateUpdateMetadata
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param metadataUpdate Contains the Keyfactor certificate identifier and the metadata to be updated (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateUpdateMetadataCall(String xKeyfactorRequestedWith, ModelsMetadataUpdateRequest metadataUpdate, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = metadataUpdate;

        // create path and map variables
        String localVarPath = "/Certificates/Metadata";

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (collectionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("collectionId", collectionId));
        }

        if (xKeyfactorApiVersion != null) {
            localVarHeaderParams.put("x-keyfactor-api-version", localVarApiClient.parameterToString(xKeyfactorApiVersion));
        }

        if (xKeyfactorRequestedWith != null) {
            localVarHeaderParams.put("x-keyfactor-requested-with", localVarApiClient.parameterToString(xKeyfactorRequestedWith));
        }

        final String[] localVarAccepts = {
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
            "application/json",
            "text/json",
            "application/xml",
            "text/xml",
            "application/x-www-form-urlencoded"
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "PUT", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateUpdateMetadataValidateBeforeCall(String xKeyfactorRequestedWith, ModelsMetadataUpdateRequest metadataUpdate, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'xKeyfactorRequestedWith' is set
        if (xKeyfactorRequestedWith == null) {
            throw new ApiException("Missing the required parameter 'xKeyfactorRequestedWith' when calling certificateUpdateMetadata(Async)");
        }

        // verify the required parameter 'metadataUpdate' is set
        if (metadataUpdate == null) {
            throw new ApiException("Missing the required parameter 'metadataUpdate' when calling certificateUpdateMetadata(Async)");
        }

        return certificateUpdateMetadataCall(xKeyfactorRequestedWith, metadataUpdate, collectionId, xKeyfactorApiVersion, _callback);

    }

    /**
     * Updates the metadata for the certificate associated with the identifier provided
     * 
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param metadataUpdate Contains the Keyfactor certificate identifier and the metadata to be updated (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public void certificateUpdateMetadata(String xKeyfactorRequestedWith, ModelsMetadataUpdateRequest metadataUpdate, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        certificateUpdateMetadataWithHttpInfo(xKeyfactorRequestedWith, metadataUpdate, collectionId, xKeyfactorApiVersion);
    }

    /**
     * Updates the metadata for the certificate associated with the identifier provided
     * 
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param metadataUpdate Contains the Keyfactor certificate identifier and the metadata to be updated (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ApiResponse&lt;Void&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<Void> certificateUpdateMetadataWithHttpInfo(String xKeyfactorRequestedWith, ModelsMetadataUpdateRequest metadataUpdate, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        okhttp3.Call localVarCall = certificateUpdateMetadataValidateBeforeCall(xKeyfactorRequestedWith, metadataUpdate, collectionId, xKeyfactorApiVersion, null);
        return localVarApiClient.execute(localVarCall);
    }

    /**
     * Updates the metadata for the certificate associated with the identifier provided (asynchronously)
     * 
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param metadataUpdate Contains the Keyfactor certificate identifier and the metadata to be updated (required)
     * @param collectionId Optional certificate collection identifier used to ensure user access to the certificate (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 204 </td><td> No Content </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateUpdateMetadataAsync(String xKeyfactorRequestedWith, ModelsMetadataUpdateRequest metadataUpdate, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback<Void> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateUpdateMetadataValidateBeforeCall(xKeyfactorRequestedWith, metadataUpdate, collectionId, xKeyfactorApiVersion, _callback);
        localVarApiClient.executeAsync(localVarCall, _callback);
        return localVarCall;
    }
    /**
     * Build call for certificateValidateCertificate
     * @param id The Id of the certificate being checked (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId An optional parameter for the collectin Id the certificate is in.  Defaults to no collection (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback Callback for upload/download progress
     * @return Call to execute
     * @throws ApiException If fail to serialize the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateValidateCertificateCall(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        String basePath = null;
        // Operation Servers
        String[] localBasePaths = new String[] {  };

        // Determine Base Path to Use
        if (localCustomBaseUrl != null){
            basePath = localCustomBaseUrl;
        } else if ( localBasePaths.length > 0 ) {
            basePath = localBasePaths[localHostIndex];
        } else {
            basePath = null;
        }

        Object localVarPostBody = null;

        // create path and map variables
        String localVarPath = "/Certificates/{id}/Validate"
            .replace("{" + "id" + "}", localVarApiClient.escapeString(id.toString()));

        List<Pair> localVarQueryParams = new ArrayList<Pair>();
        List<Pair> localVarCollectionQueryParams = new ArrayList<Pair>();
        Map<String, String> localVarHeaderParams = new HashMap<String, String>();
        Map<String, String> localVarCookieParams = new HashMap<String, String>();
        Map<String, Object> localVarFormParams = new HashMap<String, Object>();

        if (collectionId != null) {
            localVarQueryParams.addAll(localVarApiClient.parameterToPair("collectionId", collectionId));
        }

        if (xKeyfactorApiVersion != null) {
            localVarHeaderParams.put("x-keyfactor-api-version", localVarApiClient.parameterToString(xKeyfactorApiVersion));
        }

        if (xKeyfactorRequestedWith != null) {
            localVarHeaderParams.put("x-keyfactor-requested-with", localVarApiClient.parameterToString(xKeyfactorRequestedWith));
        }

        final String[] localVarAccepts = {
            "application/json",
            "text/json",
            "application/xml",
            "text/xml"
        };
        final String localVarAccept = localVarApiClient.selectHeaderAccept(localVarAccepts);
        if (localVarAccept != null) {
            localVarHeaderParams.put("Accept", localVarAccept);
        }

        final String[] localVarContentTypes = {
        };
        final String localVarContentType = localVarApiClient.selectHeaderContentType(localVarContentTypes);
        if (localVarContentType != null) {
            localVarHeaderParams.put("Content-Type", localVarContentType);
        }

        String[] localVarAuthNames = new String[] {  };
        return localVarApiClient.buildCall(basePath, localVarPath, "GET", localVarQueryParams, localVarCollectionQueryParams, localVarPostBody, localVarHeaderParams, localVarCookieParams, localVarFormParams, localVarAuthNames, _callback);
    }

    @SuppressWarnings("rawtypes")
    private okhttp3.Call certificateValidateCertificateValidateBeforeCall(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback _callback) throws ApiException {
        // verify the required parameter 'id' is set
        if (id == null) {
            throw new ApiException("Missing the required parameter 'id' when calling certificateValidateCertificate(Async)");
        }

        // verify the required parameter 'xKeyfactorRequestedWith' is set
        if (xKeyfactorRequestedWith == null) {
            throw new ApiException("Missing the required parameter 'xKeyfactorRequestedWith' when calling certificateValidateCertificate(Async)");
        }

        return certificateValidateCertificateCall(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion, _callback);

    }

    /**
     * Validates the certificate chain can be built.
     * 
     * @param id The Id of the certificate being checked (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId An optional parameter for the collectin Id the certificate is in.  Defaults to no collection (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ModelsCertificateValidationResponse
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ModelsCertificateValidationResponse certificateValidateCertificate(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        ApiResponse<ModelsCertificateValidationResponse> localVarResp = certificateValidateCertificateWithHttpInfo(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion);
        return localVarResp.getData();
    }

    /**
     * Validates the certificate chain can be built.
     * 
     * @param id The Id of the certificate being checked (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId An optional parameter for the collectin Id the certificate is in.  Defaults to no collection (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @return ApiResponse&lt;ModelsCertificateValidationResponse&gt;
     * @throws ApiException If fail to call the API, e.g. server error or cannot deserialize the response body
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public ApiResponse<ModelsCertificateValidationResponse> certificateValidateCertificateWithHttpInfo(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion) throws ApiException {
        okhttp3.Call localVarCall = certificateValidateCertificateValidateBeforeCall(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion, null);
        Type localVarReturnType = new TypeToken<ModelsCertificateValidationResponse>(){}.getType();
        return localVarApiClient.execute(localVarCall, localVarReturnType);
    }

    /**
     * Validates the certificate chain can be built. (asynchronously)
     * 
     * @param id The Id of the certificate being checked (required)
     * @param xKeyfactorRequestedWith Type of the request [XMLHttpRequest, APIClient] (required)
     * @param collectionId An optional parameter for the collectin Id the certificate is in.  Defaults to no collection (optional)
     * @param xKeyfactorApiVersion Desired version of the api, if not provided defaults to v1 (optional, default to 1)
     * @param _callback The callback to be executed when the API call finishes
     * @return The request call
     * @throws ApiException If fail to process the API call, e.g. serializing the request body object
     * @http.response.details
     <table summary="Response Details" border="1">
        <tr><td> Status Code </td><td> Description </td><td> Response Headers </td></tr>
        <tr><td> 200 </td><td> OK </td><td>  -  </td></tr>
     </table>
     */
    public okhttp3.Call certificateValidateCertificateAsync(Integer id, String xKeyfactorRequestedWith, Integer collectionId, String xKeyfactorApiVersion, final ApiCallback<ModelsCertificateValidationResponse> _callback) throws ApiException {

        okhttp3.Call localVarCall = certificateValidateCertificateValidateBeforeCall(id, xKeyfactorRequestedWith, collectionId, xKeyfactorApiVersion, _callback);
        Type localVarReturnType = new TypeToken<ModelsCertificateValidationResponse>(){}.getType();
        localVarApiClient.executeAsync(localVarCall, localVarReturnType, _callback);
        return localVarCall;
    }
}
